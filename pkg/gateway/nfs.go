// Package gateway provides NFS gateway functionality
package gateway

import (
	"context"
	"fmt"
	"net"
	"os"
	"path/filepath"
	"strings"

	"go.uber.org/zap"
	v1 "github.com/liliang-cn/sds/api/proto/v1"
)

// NFSManager handles NFS gateway operations
type NFSManager struct {
	*Manager
}

// NewNFSManager creates a new NFS gateway manager
func NewNFSManager(m *Manager) *NFSManager {
	return &NFSManager{Manager: m}
}

// CreateNFSGateway creates an NFS gateway with drbd-reactor configuration
func (n *NFSManager) CreateNFSGateway(ctx context.Context, req *v1.CreateNFSGatewayRequest) (*v1.CreateNFSGatewayResponse, error) {
	n.logger.Info("Creating NFS gateway",
		zap.String("resource", req.Resource),
		zap.String("service_ip", req.ServiceIp),
		zap.String("export_path", req.ExportPath))

	// Parse service IP
	serviceIP, err := parseServiceIP(req.ServiceIp)
	if err != nil {
		return &v1.CreateNFSGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("invalid service IP: %v", err),
		}, err
	}

	// Get volume info from resource - NFS requires at least 2 volumes
	// Volume 0: cluster-private (NFS state), Volume 1+: exported data
	resInfo, err := n.resources.GetResource(ctx, req.Resource)
	if err != nil {
		return &v1.CreateNFSGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("failed to get resource info: %v", err),
		}, err
	}

	if len(resInfo.Volumes) < 2 {
		return &v1.CreateNFSGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("NFS gateway requires at least 2 volumes (got %d): volume 0 for cluster-private, volume 1+ for exports", len(resInfo.Volumes)),
		}, fmt.Errorf("resource %s has insufficient volumes for NFS gateway (need >= 2, got %d)", req.Resource, len(resInfo.Volumes))
	}

	// Get DRBD device for the resource
	drbdDevice, err := n.getDRBDDevice(ctx, req.Resource)
	if err != nil {
		n.logger.Warn("Failed to get DRBD device, using fallback",
			zap.String("resource", req.Resource),
			zap.Error(err))
		drbdDevice = "/dev/drbd0"
	}

	n.logger.Info("Using DRBD device for NFS gateway",
		zap.String("resource", req.Resource),
		zap.String("device", drbdDevice),
		zap.Int("volume_count", len(resInfo.Volumes)))

	// Generate drbd-reactor configuration
	config, err := n.generateNFSGatewayConfig(req, serviceIP, drbdDevice)
	if err != nil {
		return &v1.CreateNFSGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("failed to generate config: %v", err),
		}, err
	}

	// Write configuration to all nodes
	pluginID := fmt.Sprintf("sds-nfs-%s", req.Resource)
	if err := n.writeReactorConfig(ctx, req.Resource, pluginID, config); err != nil {
		return &v1.CreateNFSGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("failed to write config: %v", err),
		}, err
	}

	configPath := filepath.Join(DrbdReactorConfigDir, fmt.Sprintf("%s.toml", pluginID))

	// Set resource to Primary on the first node
	if len(n.hosts) > 0 {
		primaryNode := n.hosts[0]
		n.logger.Info("Setting resource to Primary for gateway",
			zap.String("resource", req.Resource),
			zap.String("node", primaryNode))

		if err := n.resources.SetPrimary(ctx, req.Resource, primaryNode, false); err != nil {
			n.logger.Warn("Failed to set resource to Primary",
				zap.String("resource", req.Resource),
				zap.String("node", primaryNode),
				zap.Error(err))
		}
	}

	return &v1.CreateNFSGatewayResponse{
		Success:    true,
		Message:    "NFS gateway configuration created successfully",
		ConfigPath: configPath,
	}, nil
}

// generateNFSGatewayConfig generates drbd-reactor TOML configuration for NFS gateway
func (n *NFSManager) generateNFSGatewayConfig(req *v1.CreateNFSGatewayRequest, serviceIP *ServiceIP, drbdDevice string) (string, error) {
	// Template for NFS gateway - matches linstor-gateway pattern
	tmpl := `# SDS NFS Gateway Configuration
# Generated by SDS Controller
# Resource: {{ .Resource }}
# Service IP: {{ .ServiceIP }}
# Export Path: {{ .ExportPath }}

[[promoter]]

  [promoter.metadata]
    linstor-gateway-schema-version = 1

  [promoter.resources]

    [promoter.resources.{{ .Resource }}]
      on-drbd-demote-failure = "reboot-immediate"
      runner = "systemd"
      stop-services-on-exit = true
      target-as = "BindsTo"

      start = [
        "ocf:heartbeat:portblock portblock ip={{ .IPAddress }} portno={{ .NFSPort }} action=block protocol=tcp",
        "ocf:heartbeat:Filesystem fs_cluster_private device={{ .DRBDDevice }} directory={{ .ClusterPrivatePath }} fstype={{ .FSType }} run_fsck=no",
        "ocf:heartbeat:Filesystem fs_export device={{ .ExportDevice }} directory={{ .ExportPath }} fstype={{ .FSType }} run_fsck=no",
        "ocf:heartbeat:IPaddr2 service_ip ip={{ .IPAddress }} cidr_netmask={{ .Prefix }}",
        "ocf:heartbeat:nfsserver nfsserver nfs_ip={{ .IPAddress }} nfs_shared_infodir={{ .NFSInfoDir }} nfs_server_scope={{ .IPAddress }}",
{{ range $idx, $client := .AllowedClients }}
        "ocf:heartbeat:exportfs export_{{ $idx }} directory={{ $.ExportPath }} fsid={{ $.FSID }} clientspec={{ $client }} options={{ $.Options }}",
{{ end }}
        "ocf:heartbeat:portblock portunblock ip={{ .IPAddress }} portno={{ .NFSPort }} action=unblock protocol=tcp tickle_dir={{ .ClusterPrivatePath }}",
      ]
`

	ipAddr := serviceIP.IP.String()
	prefix := serviceIP.Prefix
	fsType := req.FsType
	if fsType == "" {
		fsType = DefaultFSType
	}

	// Prepare export path
	exportsPath := filepath.Join(DefaultExportBasePath, req.Resource, req.ExportPath)

	// Generate UUID-based FSID (matches linstor-gateway)
	// FSID is derived from resource UUID + volume UUID for uniqueness
	resourceUUID := generateUUID()
	volumeUUID := generateUUID()
	fsid := generateFSID(resourceUUID, volumeUUID)

	// Client specs - format as nfs CIDR notation (a.b.c.d/0.0.0.0 for /0)
	var clientSpecs []string
	if len(req.AllowedIps) > 0 {
		for _, ip := range req.AllowedIps {
			clientSpecs = append(clientSpecs, nfsFormatCIDR(ip))
		}
	} else {
		// Default: allow all
		clientSpecs = append(clientSpecs, "0.0.0.0/0.0.0.0")
	}

	options := "rw,all_squash,anonuid=0,anongid=0"

	// NFS info directory uses cluster private mount path
	nfsInfoDir := filepath.Join(DefaultClusterPrivateMountPath, req.Resource, "nfs")
	clusterPrivatePath := filepath.Join(DefaultClusterPrivateMountPath, req.Resource)

	data := struct {
		Resource           string
		ServiceIP          string
		IPAddress          string
		Prefix             int
		FSType             string
		ExportPath         string
		ExportDevice       string
		ClusterPrivatePath string
		NFSPort            int
		NFSInfoDir         string
		DRBDDevice         string
		FSID               string
		AllowedClients     []string
		Options            string
	}{
		Resource:           req.Resource,
		ServiceIP:          req.ServiceIp,
		IPAddress:          ipAddr,
		Prefix:             prefix,
		FSType:             fsType,
		DRBDDevice:         drbdDevice,
		ExportDevice:       getDRBDDeviceForVolume(drbdDevice, 1), // Volume 1 for export
		ExportPath:         exportsPath,
		ClusterPrivatePath: clusterPrivatePath,
		NFSPort:            DefaultNFSPort,
		NFSInfoDir:         nfsInfoDir,
		FSID:               fsid,
		AllowedClients:     clientSpecs,
		Options:            options,
	}

	return executeTemplate(tmpl, data)
}

// nfsFormatCIDR formats a CIDR string for NFS exportfs clientspec
// NFS requires a.b.c.d/0.0.0.0 instead of a.b.c.d/0 for IPv4
func nfsFormatCIDR(cidr string) string {
	ip, ipNet, err := net.ParseCIDR(cidr)
	if err != nil {
		return cidr
	}

	prefix, _ := ipNet.Mask.Size()

	// For IPv4 with /0, use 0.0.0.0 mask
	if ip.To4() != nil && prefix == 0 {
		return fmt.Sprintf("%s/0.0.0.0", ip.String())
	}

	// For IPv6, wrap in brackets
	if ip.To4() == nil {
		return fmt.Sprintf("[%s]/%d", ip.String(), prefix)
	}

	return cidr
}

// GetNFSGatewayStatus gets the status of an NFS gateway
func (n *NFSManager) GetNFSGatewayStatus(ctx context.Context, resource string) (map[string]interface{}, error) {
	status := map[string]interface{}{
		"type":     "nfs",
		"resource": resource,
		"status":   "unknown",
	}

	// Check if the gateway config exists
	configPath := filepath.Join(DrbdReactorConfigDir, fmt.Sprintf("sds-nfs-%s.toml", resource))
	if _, err := os.Stat(configPath); err != nil {
		status["status"] = "not_configured"
		return status, nil
	}

	status["status"] = "configured"
	status["config_path"] = configPath

	// Check if resource is primary
	if resInfo, err := n.resources.GetResource(ctx, resource); err == nil {
		status["role"] = resInfo.Role
		status["nodes"] = resInfo.Nodes
	}

	return status, nil
}

// DeleteNFSGateway deletes an NFS gateway
func (n *NFSManager) DeleteNFSGateway(ctx context.Context, resource string) error {
	n.logger.Info("Deleting NFS gateway", zap.String("resource", resource))

	configFile := fmt.Sprintf("sds-nfs-%s.toml", resource)
	configPath := filepath.Join(DrbdReactorConfigDir, configFile)

	// Remove config from all nodes
	for _, host := range n.hosts {
		rmCmd := fmt.Sprintf("sudo rm -f %s", configPath)
		if err := n.deployment.Exec(ctx, []string{host}, rmCmd); err != nil {
			n.logger.Warn("Failed to delete config",
				zap.String("node", host),
				zap.Error(err))
		}
	}

	// Reload drbd-reactor
	if err := n.reloadDrbdReactor(ctx); err != nil {
		return err
	}

	n.logger.Info("NFS gateway deleted", zap.String("resource", resource))
	return nil
}

// ==================== Multi-Export Support ====================

// AddNFSExport adds an additional export to an existing NFS gateway
func (n *NFSManager) AddNFSExport(ctx context.Context, resource, exportPath string, fsid int, clientSpec, options string) error {
	n.logger.Info("Adding NFS export",
		zap.String("resource", resource),
		zap.String("export_path", exportPath))

	// To implement: parse and append to the existing config
	return fmt.Errorf("AddNFSExport not yet implemented - please recreate gateway with all exports")
}

// ListNFSExports lists all exports for an NFS gateway
func (n *NFSManager) ListNFSExports(ctx context.Context, resource string) ([]map[string]string, error) {
	configPath := filepath.Join(DrbdReactorConfigDir, fmt.Sprintf("sds-nfs-%s.toml", resource))
	content, err := os.ReadFile(configPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read config: %w", err)
	}

	var exports []map[string]string
	lines := strings.Split(string(content), "\n")

	for _, line := range lines {
		if strings.Contains(line, "ocf:heartbeat:exportfs") {
			// Parse export line
			parts := strings.Fields(line)
			exportInfo := make(map[string]string)

			for _, part := range parts {
				if strings.HasPrefix(part, "directory=") {
					exportInfo["directory"] = strings.TrimPrefix(part, "directory=")
				} else if strings.HasPrefix(part, "fsid=") {
					exportInfo["fsid"] = strings.TrimPrefix(part, "fsid=")
				} else if strings.HasPrefix(part, "clientspec=") {
					exportInfo["clientspec"] = strings.TrimPrefix(part, "clientspec=")
				} else if strings.HasPrefix(part, "options=") {
					exportInfo["options"] = strings.TrimPrefix(part, "options=")
				}
			}

			if len(exportInfo) > 0 {
				exports = append(exports, exportInfo)
			}
		}
	}

	return exports, nil
}

// ==================== Helper Functions ====================

// parseCIDR parses a CIDR string and returns IP and prefix
func parseCIDR(cidr string) (string, int, error) {
	ip, ipNet, err := net.ParseCIDR(cidr)
	if err != nil {
		return "", 0, err
	}
	prefix, _ := ipNet.Mask.Size()
	return ip.String(), prefix, nil
}
