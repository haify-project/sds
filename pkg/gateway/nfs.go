// Package gateway provides NFS gateway functionality
package gateway

import (
	"context"
	"crypto/md5"
	"fmt"
	"net"
	"os"
	"path/filepath"
	"strings"

	"go.uber.org/zap"
	v1 "github.com/liliang-cn/sds/api/proto/v1"
)

// NFSManager handles NFS gateway operations
type NFSManager struct {
	*Manager
}

// NewNFSManager creates a new NFS gateway manager
func NewNFSManager(m *Manager) *NFSManager {
	return &NFSManager{Manager: m}
}

// CreateNFSGateway creates an NFS gateway with drbd-reactor configuration
func (n *NFSManager) CreateNFSGateway(ctx context.Context, req *v1.CreateNFSGatewayRequest) (*v1.CreateNFSGatewayResponse, error) {
	n.logger.Info("Creating NFS gateway",
		zap.String("resource", req.Resource),
		zap.String("service_ip", req.ServiceIp),
		zap.String("export_path", req.ExportPath))

	// Parse service IP
	serviceIP, err := parseServiceIP(req.ServiceIp)
	if err != nil {
		return &v1.CreateNFSGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("invalid service IP: %v", err),
		}, err
	}

	// Get DRBD device for the resource
	drbdDevice, err := n.getDRBDDevice(ctx, req.Resource)
	if err != nil {
		n.logger.Warn("Failed to get DRBD device, using fallback",
			zap.String("resource", req.Resource),
			zap.Error(err))
		drbdDevice = "/dev/drbd0"
	}

	n.logger.Info("Using DRBD device for NFS gateway",
		zap.String("resource", req.Resource),
		zap.String("device", drbdDevice))

	// Generate drbd-reactor configuration
	config, err := n.generateNFSGatewayConfig(req, serviceIP, drbdDevice)
	if err != nil {
		return &v1.CreateNFSGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("failed to generate config: %v", err),
		}, err
	}

	// Write configuration to all nodes
	pluginID := fmt.Sprintf("sds-nfs-%s", req.Resource)
	if err := n.writeReactorConfig(ctx, req.Resource, pluginID, config); err != nil {
		return &v1.CreateNFSGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("failed to write config: %v", err),
		}, err
	}

	configPath := filepath.Join(DrbdReactorConfigDir, fmt.Sprintf("%s.toml", pluginID))

	// Set resource to Primary on the first node
	if len(n.hosts) > 0 {
		primaryNode := n.hosts[0]
		n.logger.Info("Setting resource to Primary for gateway",
			zap.String("resource", req.Resource),
			zap.String("node", primaryNode))

		if err := n.resources.SetPrimary(ctx, req.Resource, primaryNode, false); err != nil {
			n.logger.Warn("Failed to set resource to Primary",
				zap.String("resource", req.Resource),
				zap.String("node", primaryNode),
				zap.Error(err))
		}
	}

	return &v1.CreateNFSGatewayResponse{
		Success:    true,
		Message:    "NFS gateway configuration created successfully",
		ConfigPath: configPath,
	}, nil
}

// generateNFSGatewayConfig generates drbd-reactor TOML configuration for NFS gateway
func (n *NFSManager) generateNFSGatewayConfig(req *v1.CreateNFSGatewayRequest, serviceIP *ServiceIP, drbdDevice string) (string, error) {
	// Template for NFS gateway
	tmpl := `# SDS NFS Gateway Configuration
# Generated by SDS Controller
# Resource: {{ .Resource }}
# Service IP: {{ .ServiceIP }}
# Export Path: {{ .ExportPath }}

[[promoter]]

  [promoter.metadata]
    linstor-gateway-schema-version = 1

  [promoter.resources]

    [promoter.resources.{{ .Resource }}]
      on-drbd-demote-failure = "reboot-immediate"
      runner = "systemd"
      start = [
        "ocf:heartbeat:Filesystem fs_cluster_private device={{ .DRBDDevice }} directory={{ .ClusterPrivatePath }} fstype={{ .FSType }} run_fsck=no",
        "ocf:heartbeat:Filesystem fs_export device={{ .DRBDDevice }} directory={{ .ExportPath }} fstype={{ .FSType }} run_fsck=no",
        "ocf:heartbeat:IPaddr2 service_ip ip={{ .IPAddress }} cidr_netmask={{ .Prefix }}",
        "ocf:heartbeat:nfsserver nfsserver nfs_ip={{ .IPAddress }} nfs_shared_infodir={{ .NFSInfoDir }} nfs_server_scope={{ .IPAddress }}",
        "ocf:heartbeat:exportfs export_0 directory={{ .ExportPath }} fsid={{ .FSID }} clientspec={{ .ClientSpec }} options={{ .Options }}",
      ]
      stop-services-on-exit = true
      target-as = "BindsTo"
`

	ipAddr := serviceIP.IP.String()
	prefix := serviceIP.Prefix
	fsType := req.FsType
	if fsType == "" {
		fsType = DefaultFSType
	}

	// Prepare export path
	exportsPath := filepath.Join(DefaultExportBasePath, req.Resource, req.ExportPath)

	// Generate a simple numeric FSID based on resource name hash
	hash := md5.Sum([]byte(req.Resource))
	fsid := int(hash[0])<<24 | int(hash[1])<<16 | int(hash[2])<<8 | int(hash[3])
	if fsid < 0 {
		fsid = -fsid
	}
	fsid = (fsid % 1000000) + 100

	// Client spec and options
	clientSpec := "0.0.0.0/0.0.0.0"
	options := "rw,all_squash,anonuid=0,anongid=0"

	if len(req.AllowedIps) > 0 {
		clientSpec = req.AllowedIps[0]
	}

	nfsInfoDir := filepath.Join(DefaultClusterPrivateMountPath, req.Resource+"-cluster-private", "nfs")

	data := struct {
		Resource           string
		ServiceIP          string
		IPAddress          string
		Prefix             int
		FSType             string
		ExportPath         string
		ClusterPrivatePath string
		NFSPort            int
		NFSInfoDir         string
		DRBDDevice         string
		FSID               int
		ClientSpec         string
		Options            string
	}{
		Resource:           req.Resource,
		ServiceIP:          req.ServiceIp,
		IPAddress:          ipAddr,
		Prefix:             prefix,
		FSType:             fsType,
		DRBDDevice:         drbdDevice,
		ExportPath:         exportsPath,
		ClusterPrivatePath: filepath.Join(DefaultClusterPrivateMountPath, req.Resource+"-cluster-private"),
		NFSPort:            DefaultNFSPort,
		NFSInfoDir:         nfsInfoDir,
		FSID:               fsid,
		ClientSpec:         clientSpec,
		Options:            options,
	}

	return executeTemplate(tmpl, data)
}

// GetNFSGatewayStatus gets the status of an NFS gateway
func (n *NFSManager) GetNFSGatewayStatus(ctx context.Context, resource string) (map[string]interface{}, error) {
	status := map[string]interface{}{
		"type":     "nfs",
		"resource": resource,
		"status":   "unknown",
	}

	// Check if the gateway config exists
	configPath := filepath.Join(DrbdReactorConfigDir, fmt.Sprintf("sds-nfs-%s.toml", resource))
	if _, err := os.Stat(configPath); err != nil {
		status["status"] = "not_configured"
		return status, nil
	}

	status["status"] = "configured"
	status["config_path"] = configPath

	// Check if resource is primary
	if resInfo, err := n.resources.GetResource(ctx, resource); err == nil {
		status["role"] = resInfo.Role
		status["nodes"] = resInfo.Nodes
	}

	return status, nil
}

// DeleteNFSGateway deletes an NFS gateway
func (n *NFSManager) DeleteNFSGateway(ctx context.Context, resource string) error {
	n.logger.Info("Deleting NFS gateway", zap.String("resource", resource))

	configFile := fmt.Sprintf("sds-nfs-%s.toml", resource)
	configPath := filepath.Join(DrbdReactorConfigDir, configFile)

	// Remove config from all nodes
	for _, host := range n.hosts {
		rmCmd := fmt.Sprintf("sudo rm -f %s", configPath)
		if err := n.deployment.Exec(ctx, []string{host}, rmCmd); err != nil {
			n.logger.Warn("Failed to delete config",
				zap.String("node", host),
				zap.Error(err))
		}
	}

	// Reload drbd-reactor
	if err := n.reloadDrbdReactor(ctx); err != nil {
		return err
	}

	n.logger.Info("NFS gateway deleted", zap.String("resource", resource))
	return nil
}

// ==================== Multi-Export Support ====================

// AddNFSExport adds an additional export to an existing NFS gateway
func (n *NFSManager) AddNFSExport(ctx context.Context, resource, exportPath string, fsid int, clientSpec, options string) error {
	n.logger.Info("Adding NFS export",
		zap.String("resource", resource),
		zap.String("export_path", exportPath))

	// To implement: parse and append to the existing config
	return fmt.Errorf("AddNFSExport not yet implemented - please recreate gateway with all exports")
}

// ListNFSExports lists all exports for an NFS gateway
func (n *NFSManager) ListNFSExports(ctx context.Context, resource string) ([]map[string]string, error) {
	configPath := filepath.Join(DrbdReactorConfigDir, fmt.Sprintf("sds-nfs-%s.toml", resource))
	content, err := os.ReadFile(configPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read config: %w", err)
	}

	var exports []map[string]string
	lines := strings.Split(string(content), "\n")

	for _, line := range lines {
		if strings.Contains(line, "ocf:heartbeat:exportfs") {
			// Parse export line
			parts := strings.Fields(line)
			exportInfo := make(map[string]string)

			for _, part := range parts {
				if strings.HasPrefix(part, "directory=") {
					exportInfo["directory"] = strings.TrimPrefix(part, "directory=")
				} else if strings.HasPrefix(part, "fsid=") {
					exportInfo["fsid"] = strings.TrimPrefix(part, "fsid=")
				} else if strings.HasPrefix(part, "clientspec=") {
					exportInfo["clientspec"] = strings.TrimPrefix(part, "clientspec=")
				} else if strings.HasPrefix(part, "options=") {
					exportInfo["options"] = strings.TrimPrefix(part, "options=")
				}
			}

			if len(exportInfo) > 0 {
				exports = append(exports, exportInfo)
			}
		}
	}

	return exports, nil
}

// ==================== Helper Functions ====================

// parseCIDR parses a CIDR string and returns IP and prefix
func parseCIDR(cidr string) (string, int, error) {
	ip, ipNet, err := net.ParseCIDR(cidr)
	if err != nil {
		return "", 0, err
	}
	prefix, _ := ipNet.Mask.Size()
	return ip.String(), prefix, nil
}

// generateFSID generates a filesystem ID based on resource and export path
func generateFSID(resource, exportPath string) int {
	hash := md5.Sum([]byte(resource + ":" + exportPath))
	return (int(hash[0])<<24 | int(hash[1])<<16 | int(hash[2])<<8 | int(hash[3])) % 1000000
}
