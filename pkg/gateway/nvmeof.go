// Package gateway provides NVMe-oF gateway functionality
package gateway

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"go.uber.org/zap"
	v1 "github.com/liliang-cn/sds/api/proto/v1"
)

// NVMeManager handles NVMe-oF gateway operations
type NVMeManager struct {
	*Manager
}

// NewNVMeManager creates a new NVMe-oF gateway manager
func NewNVMeManager(m *Manager) *NVMeManager {
	return &NVMeManager{Manager: m}
}

// CreateNVMeGateway creates an NVMe-oF gateway with drbd-reactor configuration
func (n *NVMeManager) CreateNVMeGateway(ctx context.Context, req *v1.CreateNVMeGatewayRequest) (*v1.CreateNVMeGatewayResponse, error) {
	n.logger.Info("Creating NVMe-oF gateway",
		zap.String("resource", req.Resource),
		zap.String("nqn", req.Nqn),
		zap.String("service_ip", req.ServiceIp))

	// Parse service IP
	serviceIP, err := parseServiceIP(req.ServiceIp)
	if err != nil {
		return &v1.CreateNVMeGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("invalid service IP: %v", err),
		}, err
	}

	// Get volume info from resource - NVMe-oF requires at least 2 volumes
	// Volume 0: cluster-private, Volume 1+: namespaces exposed to initiators
	resInfo, err := n.resources.GetResource(ctx, req.Resource)
	if err != nil {
		return &v1.CreateNVMeGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("failed to get resource info: %v", err),
		}, err
	}

	if len(resInfo.Volumes) < 2 {
		return &v1.CreateNVMeGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("NVMe-oF gateway requires at least 2 volumes (got %d): volume 0 for cluster-private, volume 1+ for namespaces", len(resInfo.Volumes)),
		}, fmt.Errorf("resource %s has insufficient volumes for NVMe-oF gateway (need >= 2, got %d)", req.Resource, len(resInfo.Volumes))
	}

	// Get DRBD device for the resource
	drbdDevice, err := n.getDRBDDevice(ctx, req.Resource)
	if err != nil {
		n.logger.Warn("Failed to get DRBD device, using fallback",
			zap.String("resource", req.Resource),
			zap.Error(err))
		drbdDevice = "/dev/drbd0"
	}

	n.logger.Info("Using DRBD device for NVMe-oF gateway",
		zap.String("resource", req.Resource),
		zap.String("device", drbdDevice),
		zap.Int("volume_count", len(resInfo.Volumes)),
		zap.Int("namespace_count", len(resInfo.Volumes)-1))

	// Generate drbd-reactor configuration
	config, err := n.generateNVMeGatewayConfig(req, serviceIP, drbdDevice, len(resInfo.Volumes))
	if err != nil {
		return &v1.CreateNVMeGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("failed to generate config: %v", err),
		}, err
	}

	// Write configuration to all nodes
	pluginID := fmt.Sprintf("sds-nvmeof-%s", req.Resource)
	if err := n.writeReactorConfig(ctx, req.Resource, pluginID, config); err != nil {
		return &v1.CreateNVMeGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("failed to write config: %v", err),
		}, err
	}

	configPath := filepath.Join(DrbdReactorConfigDir, fmt.Sprintf("%s.toml", pluginID))

	// Set resource to Primary on the first node
	if len(n.hosts) > 0 {
		primaryNode := n.hosts[0]
		n.logger.Info("Setting resource to Primary for gateway",
			zap.String("resource", req.Resource),
			zap.String("node", primaryNode))

		if err := n.resources.SetPrimary(ctx, req.Resource, primaryNode, false); err != nil {
			n.logger.Warn("Failed to set resource to Primary",
				zap.String("resource", req.Resource),
				zap.String("node", primaryNode),
				zap.Error(err))
		}
	}

	return &v1.CreateNVMeGatewayResponse{
		Success:    true,
		Message:    "NVMe-oF gateway configuration created successfully",
		ConfigPath: configPath,
	}, nil
}

// generateNVMeGatewayConfig generates drbd-reactor TOML configuration for NVMe-oF gateway
func (n *NVMeManager) generateNVMeGatewayConfig(req *v1.CreateNVMeGatewayRequest, serviceIP *ServiceIP, drbdDevice string, volumeCount int) (string, error) {
	// Template for NVMe-oF gateway - matches linstor-gateway pattern
	tmpl := `# SDS NVMe-oF Gateway Configuration
# Generated by SDS Controller
# Resource: {{ .Resource }}
# NQN: {{ .NQN }}
# Service IP: {{ .ServiceIP }}

[[promoter]]

  [promoter.metadata]
    linstor-gateway-schema-version = 1

  [promoter.resources]

    [promoter.resources.{{ .SubsystemID }}]
      on-drbd-demote-failure = "reboot-immediate"
      runner = "systemd"
      stop-services-on-exit = true
      target-as = "Requires"

      start = [
        "ocf:heartbeat:portblock portblock ip={{ .IPAddress }} portno={{ .NVMePort }} action=block protocol=tcp",
        "ocf:heartbeat:Filesystem fs_cluster_private device={{ .DRBDDevice }} directory={{ .ClusterPrivatePath }} fstype={{ .FSType }} run_fsck=no",
        "ocf:heartbeat:IPaddr2 service_ip ip={{ .IPAddress }} cidr_netmask={{ .Prefix }}",
        "ocf:heartbeat:nvmet-subsystem subsys nqn={{ .NQN }} serial={{ .Serial }}",
{{ range $idx, $ns := .Namespaces }}
        "ocf:heartbeat:nvmet-namespace ns_{{ $ns.Number }} nqn={{ $.NQN }} namespace_id={{ $ns.Number }} backing_path={{ $ns.Device }} uuid={{ $ns.UUID }} nguid={{ $ns.NGUID }}",
{{ end }}
        "ocf:heartbeat:nvmet-port port nqns={{ .NQN }} addr={{ .IPAddress }} type={{ .TransportType }}",
        "ocf:heartbeat:portblock portunblock ip={{ .IPAddress }} portno={{ .NVMePort }} action=unblock protocol=tcp tickle_dir={{ .ClusterPrivatePath }}",
      ]
`

	ipAddr := serviceIP.IP.String()
	prefix := serviceIP.Prefix

	transportType := req.TransportType
	if transportType == "" {
		transportType = "tcp"
	}

	// Generate serial from NQN using SHA256 (matches linstor-gateway)
	digest := sha256.Sum256([]byte(req.Nqn))
	serial := hex.EncodeToString(digest[:8])

	// Prepare subsystem ID (extract subsystem name from NQN)
	// Format: nqn.2024-01.com.example:subsystem.name -> subsystem.name
	subsystemID := req.Nqn
	if parts := strings.SplitN(req.Nqn, ":", 2); len(parts) == 2 {
		subsystemID = parts[1]
	}

	// Prepare namespace data - Volume 0 is cluster-private, volumes 1+ are namespaces
	// NVMe namespaces start at 1
	type Namespace struct {
		Number int
		Device string
		UUID   string
		NGUID  string
	}

	namespaces := make([]Namespace, volumeCount)
	for v := 0; v < volumeCount; v++ {
		if v == 0 {
			// Volume 0 - cluster private (not exposed as namespace)
			namespaces[v] = Namespace{
				Number: 0,
				Device: drbdDevice,
				UUID:   generateUUID(),
				NGUID:  generateUUID(),
			}
		} else {
			// Volume N - exposed as namespace N (NVMe namespaces start at 1)
			namespaces[v] = Namespace{
				Number: v,
				Device: getDRBDDeviceForVolume(drbdDevice, v),
				UUID:   generateUUID(),
				NGUID:  generateUUID(),
			}
		}
	}

	clusterPrivatePath := filepath.Join(DefaultClusterPrivateMountPath, req.Resource)

	data := struct {
		Resource           string
		NQN                string
		SubsystemID        string
		ServiceIP          string
		IPAddress          string
		Prefix             int
		FSType             string
		ClusterPrivatePath string
		NVMePort           int
		Serial             string
		TransportType      string
		Namespaces         []Namespace
		DRBDDevice         string
	}{
		Resource:           req.Resource,
		NQN:                req.Nqn,
		SubsystemID:        subsystemID,
		ServiceIP:          req.ServiceIp,
		IPAddress:          ipAddr,
		Prefix:             prefix,
		FSType:             DefaultFSType,
		DRBDDevice:         drbdDevice,
		ClusterPrivatePath: clusterPrivatePath,
		NVMePort:           DefaultNVMePort,
		Serial:             serial,
		TransportType:      transportType,
		Namespaces:         namespaces,
	}

	return executeTemplate(tmpl, data)
}

// GetNVMeGatewayStatus gets the status of an NVMe-oF gateway
func (n *NVMeManager) GetNVMeGatewayStatus(ctx context.Context, resource string) (map[string]interface{}, error) {
	status := map[string]interface{}{
		"type":     "nvmeof",
		"resource": resource,
		"status":   "unknown",
	}

	// Check if the gateway config exists
	configPath := filepath.Join(DrbdReactorConfigDir, fmt.Sprintf("sds-nvmeof-%s.toml", resource))
	if _, err := os.Stat(configPath); err != nil {
		status["status"] = "not_configured"
		return status, nil
	}

	status["status"] = "configured"
	status["config_path"] = configPath

	// Check if resource is primary
	if resInfo, err := n.resources.GetResource(ctx, resource); err == nil {
		status["role"] = resInfo.Role
		status["nodes"] = resInfo.Nodes
		status["volumes"] = len(resInfo.Volumes)
	}

	return status, nil
}

// DeleteNVMeGateway deletes an NVMe-oF gateway
func (n *NVMeManager) DeleteNVMeGateway(ctx context.Context, resource string) error {
	n.logger.Info("Deleting NVMe-oF gateway", zap.String("resource", resource))

	configFile := fmt.Sprintf("sds-nvmeof-%s.toml", resource)
	configPath := filepath.Join(DrbdReactorConfigDir, configFile)

	// Remove config from all nodes
	for _, host := range n.hosts {
		rmCmd := fmt.Sprintf("sudo rm -f %s", configPath)
		if err := n.deployment.Exec(ctx, []string{host}, rmCmd); err != nil {
			n.logger.Warn("Failed to delete config",
				zap.String("node", host),
				zap.Error(err))
		}
	}

	// Reload drbd-reactor
	if err := n.reloadDrbdReactor(ctx); err != nil {
		return err
	}

	n.logger.Info("NVMe-oF gateway deleted", zap.String("resource", resource))
	return nil
}

// ==================== Namespace Management ====================

// AddNamespace adds a namespace to an existing NVMe-oF gateway
func (n *NVMeManager) AddNamespace(ctx context.Context, resource, device string) error {
	n.logger.Info("Adding namespace to NVMe-oF gateway",
		zap.String("resource", resource),
		zap.String("device", device))

	return fmt.Errorf("AddNamespace not yet implemented - please recreate gateway with all namespaces")
}

// RemoveNamespace removes a namespace from an NVMe-oF gateway
func (n *NVMeManager) RemoveNamespace(ctx context.Context, resource string, nsid int) error {
	n.logger.Info("Removing namespace from NVMe-oF gateway",
		zap.String("resource", resource),
		zap.Int("nsid", nsid))

	return fmt.Errorf("RemoveNamespace not yet implemented")
}

// ListNamespaces lists all namespaces for an NVMe-oF gateway
func (n *NVMeManager) ListNamespaces(ctx context.Context, resource string) ([]map[string]string, error) {
	// Query nvmetcli for configured namespaces
	return []map[string]string{}, nil
}

// ==================== Subsystem Management ====================

// CreateSubsystem creates an NVMe subsystem
func (n *NVMeManager) CreateSubsystem(ctx context.Context, resource, nqn string) error {
	n.logger.Info("Creating NVMe subsystem",
		zap.String("resource", resource),
		zap.String("nqn", nqn))

	// Use nvmetcli or configuration files to create the subsystem
	return fmt.Errorf("CreateSubsystem: managed by OCF resource agent")
}

// DeleteSubsystem deletes an NVMe subsystem
func (n *NVMeManager) DeleteSubsystem(ctx context.Context, nqn string) error {
	n.logger.Info("Deleting NVMe subsystem", zap.String("nqn", nqn))

	return fmt.Errorf("DeleteSubsystem: use gateway deletion instead")
}

// ListSubsystems lists all NVMe subsystems
func (n *NVMeManager) ListSubsystems(ctx context.Context, host string) ([]string, error) {
	// Query nvmetcli for configured subsystems
	return []string{}, nil
}

// ==================== Host Management ====================

// AddHost adds a host (initiator) to the NVMe subsystem
func (n *NVMeManager) AddHost(ctx context.Context, resource, hostNQN string) error {
	n.logger.Info("Adding host to NVMe subsystem",
		zap.String("resource", resource),
		zap.String("host_nqn", hostNQN))

	return fmt.Errorf("AddHost not yet implemented - please recreate gateway")
}

// RemoveHost removes a host from the NVMe subsystem
func (n *NVMeManager) RemoveHost(ctx context.Context, resource, hostNQN string) error {
	n.logger.Info("Removing host from NVMe subsystem",
		zap.String("resource", resource),
		zap.String("host_nqn", hostNQN))

	return fmt.Errorf("RemoveHost not yet implemented")
}

// ListHosts lists all hosts for an NVMe subsystem
func (n *NVMeManager) ListHosts(ctx context.Context, resource string) ([]string, error) {
	return []string{}, nil
}

// ==================== Port Management ====================

// CreatePort creates an NVMe port (transport endpoint)
func (n *NVMeManager) CreatePort(ctx context.Context, resource, addr string, port int) error {
	n.logger.Info("Creating NVMe port",
		zap.String("resource", resource),
		zap.String("addr", addr),
		zap.Int("port", port))

	return fmt.Errorf("CreatePort: managed by OCF resource agent")
}

// DeletePort deletes an NVMe port
func (n *NVMeManager) DeletePort(ctx context.Context, resource, addr string, port int) error {
	n.logger.Info("Deleting NVMe port",
		zap.String("resource", resource),
		zap.String("addr", addr),
		zap.Int("port", port))

	return fmt.Errorf("DeletePort not yet implemented")
}

// ListPorts lists all ports for an NVMe subsystem
func (n *NVMeManager) ListPorts(ctx context.Context, resource string) ([]map[string]string, error) {
	return []map[string]string{}, nil
}

// ==================== Helper Functions ====================

// generateNQN generates an NVMe qualified name for a given resource
func generateNQN(resource string) string {
	// Format: nqn.2024-01.com.example:sds.resource-name
	return fmt.Sprintf("nqn.2024-01.com.example:sds.%s", resource)
}

// validateNQN validates an NQN format
func validateNQN(nqn string) error {
	if !strings.HasPrefix(nqn, "nqn.") {
		return fmt.Errorf("invalid NQN format: must start with 'nqn.'")
	}

	parts := strings.Split(nqn, ":")
	if len(parts) < 2 {
		return fmt.Errorf("invalid NQN format: missing colon separator")
	}

	return nil
}

// parseTransportType parses and validates an NVMe transport type
func parseTransportType(transport string) error {
	validTypes := []string{"tcp", "rdma", "fc"}
	for _, t := range validTypes {
		if transport == t {
			return nil
		}
	}
	return fmt.Errorf("invalid transport type: %s (valid: %v)", transport, validTypes)
}
