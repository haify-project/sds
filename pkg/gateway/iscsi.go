// Package gateway provides iSCSI gateway functionality
package gateway

import (
	"context"
	"fmt"
	"net"
	"os"
	"path/filepath"
	"strings"

	"go.uber.org/zap"
	v1 "github.com/liliang-cn/sds/api/proto/v1"
)

// iSCSIManager handles iSCSI gateway operations
type iSCSIManager struct {
	*Manager
}

// NewISCSIManager creates a new iSCSI gateway manager
func NewISCSIManager(m *Manager) *iSCSIManager {
	return &iSCSIManager{Manager: m}
}

// CreateISCSIGateway creates an iSCSI gateway with drbd-reactor configuration
func (i *iSCSIManager) CreateISCSIGateway(ctx context.Context, req *v1.CreateISCSIGatewayRequest) (*v1.CreateISCSIGatewayResponse, error) {
	i.logger.Info("Creating iSCSI gateway",
		zap.String("resource", req.Resource),
		zap.String("iqn", req.Iqn),
		zap.String("service_ip", req.ServiceIp))

	// Parse service IP
	serviceIP, err := parseServiceIP(req.ServiceIp)
	if err != nil {
		return &v1.CreateISCSIGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("invalid service IP: %v", err),
		}, err
	}

	// Get volume info from resource - iSCSI requires at least 2 volumes
	// Volume 0: cluster-private, Volume 1+: LUNs exposed to initiators
	resInfo, err := i.resources.GetResource(ctx, req.Resource)
	if err != nil {
		return &v1.CreateISCSIGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("failed to get resource info: %v", err),
		}, err
	}

	if len(resInfo.Volumes) < 2 {
		return &v1.CreateISCSIGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("iSCSI gateway requires at least 2 volumes (got %d): volume 0 for cluster-private, volume 1+ for LUNs", len(resInfo.Volumes)),
		}, fmt.Errorf("resource %s has insufficient volumes for iSCSI gateway (need >= 2, got %d)", req.Resource, len(resInfo.Volumes))
	}

	// Get DRBD device for the resource
	drbdDevice, err := i.getDRBDDevice(ctx, req.Resource)
	if err != nil {
		i.logger.Warn("Failed to get DRBD device, using fallback",
			zap.String("resource", req.Resource),
			zap.Error(err))
		drbdDevice = "/dev/drbd0"
	}

	i.logger.Info("Using DRBD device for iSCSI gateway",
		zap.String("resource", req.Resource),
		zap.String("device", drbdDevice),
		zap.Int("volume_count", len(resInfo.Volumes)),
		zap.Int("lun_count", len(resInfo.Volumes)-1))

	// Generate drbd-reactor configuration
	config, err := i.generateISCSIGatewayConfig(req, serviceIP, drbdDevice, len(resInfo.Volumes))
	if err != nil {
		return &v1.CreateISCSIGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("failed to generate config: %v", err),
		}, err
	}

	// Write configuration to all nodes
	pluginID := fmt.Sprintf("sds-iscsi-%s", req.Resource)
	if err := i.writeReactorConfig(ctx, req.Resource, pluginID, config); err != nil {
		return &v1.CreateISCSIGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("failed to write config: %v", err),
		}, err
	}

	configPath := filepath.Join(DrbdReactorConfigDir, fmt.Sprintf("%s.toml", pluginID))

	// Set resource to Primary on the first node
	if len(i.hosts) > 0 {
		primaryNode := i.hosts[0]
		i.logger.Info("Setting resource to Primary for gateway",
			zap.String("resource", req.Resource),
			zap.String("node", primaryNode))

		if err := i.resources.SetPrimary(ctx, req.Resource, primaryNode, false); err != nil {
			i.logger.Warn("Failed to set resource to Primary",
				zap.String("resource", req.Resource),
				zap.String("node", primaryNode),
				zap.Error(err))
		}
	}

	return &v1.CreateISCSIGatewayResponse{
		Success:    true,
		Message:    "iSCSI gateway configuration created successfully",
		ConfigPath: configPath,
	}, nil
}

// generateISCSIGatewayConfig generates drbd-reactor TOML configuration for iSCSI gateway
func (i *iSCSIManager) generateISCSIGatewayConfig(req *v1.CreateISCSIGatewayRequest, serviceIP *ServiceIP, drbdDevice string, volumeCount int) (string, error) {
	// Template for iSCSI gateway - matches linstor-gateway pattern
	tmpl := `# SDS iSCSI Gateway Configuration
# Generated by SDS Controller
# Resource: {{ .Resource }}
# IQN: {{ .IQN }}
# Service IP: {{ .ServiceIP }}

[[promoter]]

  [promoter.metadata]
    linstor-gateway-schema-version = 1

  [promoter.resources]

    [promoter.resources.{{ .IQN }}]
      on-drbd-demote-failure = "reboot-immediate"
      runner = "systemd"
      stop-services-on-exit = true
      target-as = "Requires"

      start = [
        "ocf:heartbeat:Filesystem fs_cluster_private device={{ .DRBDDevice }} directory={{ .ClusterPrivatePath }} fstype={{ .FSType }} run_fsck=no",
        "ocf:heartbeat:portblock pblock0 ip={{ .IPAddress }} portno={{ .ISCSIPort }} action=block protocol=tcp",
        "ocf:heartbeat:IPaddr2 service_ip0 ip={{ .IPAddress }} cidr_netmask={{ .Prefix }}",
        "ocf:heartbeat:iSCSITarget target iqn={{ .IQN }} portals={{ .Portal }} incoming_username={{ .Username }} incoming_password={{ .Password }} allowed_initiators={{ .AllowedInitiators }} implementation={{ .Implementation }}",
{{ range $idx, $lun := .LUNs }}
        "ocf:heartbeat:iSCSILogicalUnit lu{{ $lun.Number }} target_iqn={{ $.IQN }} lun={{ $lun.Number }} path={{ $lun.Device }} product_id={{ $lun.Serial }} scsi_sn={{ $lun.Serial }}",
{{ end }}
        "ocf:heartbeat:portblock portunblock0 ip={{ .IPAddress }} portno={{ .ISCSIPort }} action=unblock protocol=tcp tickle_dir={{ .ClusterPrivatePath }}",
      ]
`

	ipAddr := serviceIP.IP.String()
	prefix := serviceIP.Prefix
	portal := fmt.Sprintf("%s:%d", ipAddr, DefaultISCSIPort)

	// Prepare LUNs - Volume 0 is cluster-private, volumes 1+ are LUNs
	// Each LUN needs a unique serial number based on IQN + volume number
	type LUN struct {
		Number  int
		Device  string
		Serial  string
	}

	luns := make([]LUN, volumeCount)
	for v := 0; v < volumeCount; v++ {
		if v == 0 {
			// Volume 0 - cluster private (not exposed as LUN)
			luns[v] = LUN{
				Number: 0,
				Device: drbdDevice,
				Serial: generateSerialFromIQN(req.Iqn, 0),
			}
		} else {
			// Volume N - exposed as LUN N
			luns[v] = LUN{
				Number: v,
				Device: getDRBDDeviceForVolume(drbdDevice, v),
				Serial: generateSerialFromIQN(req.Iqn, v),
			}
		}
	}

	// Default values
	username := req.Username
	password := req.Password
	implementation := req.Implementation
	allowedInitiators := strings.Join(req.AllowedInitiators, " ")

	if username == "" {
		username = "username"
	}
	if password == "" {
		password = "password"
	}
	if implementation == "" {
		implementation = "lio-t"
	}
	if allowedInitiators == "" {
		allowedInitiators = "ALL"
	}

	clusterPrivatePath := filepath.Join(DefaultClusterPrivateMountPath, req.Resource)

	data := struct {
		Resource           string
		IQN                string
		ServiceIP          string
		IPAddress          string
		Prefix             int
		Portal             string
		FSType             string
		ClusterPrivatePath string
		ISCSIPort          int
		Username           string
		Password           string
		AllowedInitiators  string
		Implementation     string
		LUNs               []LUN
		DRBDDevice         string
	}{
		Resource:           req.Resource,
		IQN:                req.Iqn,
		ServiceIP:          req.ServiceIp,
		IPAddress:          ipAddr,
		Prefix:             prefix,
		Portal:             portal,
		FSType:             DefaultFSType,
		DRBDDevice:         drbdDevice,
		ClusterPrivatePath: clusterPrivatePath,
		ISCSIPort:          DefaultISCSIPort,
		Username:           username,
		Password:           password,
		AllowedInitiators:  allowedInitiators,
		Implementation:     implementation,
		LUNs:               luns,
	}

	return executeTemplate(tmpl, data)
}

// GetISCSIGatewayStatus gets the status of an iSCSI gateway
func (i *iSCSIManager) GetISCSIGatewayStatus(ctx context.Context, resource string) (map[string]interface{}, error) {
	status := map[string]interface{}{
		"type":     "iscsi",
		"resource": resource,
		"status":   "unknown",
	}

	// Check if the gateway config exists
	configPath := filepath.Join(DrbdReactorConfigDir, fmt.Sprintf("sds-iscsi-%s.toml", resource))
	if _, err := os.Stat(configPath); err != nil {
		status["status"] = "not_configured"
		return status, nil
	}

	status["status"] = "configured"
	status["config_path"] = configPath

	// Check if resource is primary
	if resInfo, err := i.resources.GetResource(ctx, resource); err == nil {
		status["role"] = resInfo.Role
		status["nodes"] = resInfo.Nodes
		status["volumes"] = len(resInfo.Volumes)
	}

	return status, nil
}

// DeleteISCSIGateway deletes an iSCSI gateway
func (i *iSCSIManager) DeleteISCSIGateway(ctx context.Context, resource string) error {
	i.logger.Info("Deleting iSCSI gateway", zap.String("resource", resource))

	configFile := fmt.Sprintf("sds-iscsi-%s.toml", resource)
	configPath := filepath.Join(DrbdReactorConfigDir, configFile)

	// Remove config from all nodes
	for _, host := range i.hosts {
		rmCmd := fmt.Sprintf("sudo rm -f %s", configPath)
		if err := i.deployment.Exec(ctx, []string{host}, rmCmd); err != nil {
			i.logger.Warn("Failed to delete config",
				zap.String("node", host),
				zap.Error(err))
		}
	}

	// Reload drbd-reactor
	if err := i.reloadDrbdReactor(ctx); err != nil {
		return err
	}

	i.logger.Info("iSCSI gateway deleted", zap.String("resource", resource))
	return nil
}

// AddLUN adds a LUN to an existing iSCSI gateway
func (i *iSCSIManager) AddLUN(ctx context.Context, resource string, lunNumber int, device string) error {
	i.logger.Info("Adding LUN to iSCSI gateway",
		zap.String("resource", resource),
		zap.Int("lun", lunNumber),
		zap.String("device", device))

	// Read existing config, parse, add LUN, rewrite
	// For simplicity, return not implemented
	return fmt.Errorf("AddLUN not yet implemented - please recreate gateway with all LUNs")
}

// RemoveLUN removes a LUN from an iSCSI gateway
func (i *iSCSIManager) RemoveLUN(ctx context.Context, resource string, lunNumber int) error {
	i.logger.Info("Removing LUN from iSCSI gateway",
		zap.String("resource", resource),
		zap.Int("lun", lunNumber))

	return fmt.Errorf("RemoveLUN not yet implemented")
}

// ==================== Target Management ====================

// CreateTarget creates an iSCSI target on the gateway
func (i *iSCSIManager) CreateTarget(ctx context.Context, resource string) error {
	i.logger.Info("Creating iSCSI target", zap.String("resource", resource))

	// Use targetcli or configuration files to create the target
	// This is typically done by the OCF resource agent during start

	return fmt.Errorf("CreateTarget: managed by OCF resource agent")
}

// DeleteTarget deletes an iSCSI target
func (i *iSCSIManager) DeleteTarget(ctx context.Context, resource string) error {
	i.logger.Info("Deleting iSCSI target", zap.String("resource", resource))

	return fmt.Errorf("DeleteTarget: use gateway deletion instead")
}

// ListTargets lists all iSCSI targets
func (i *iSCSIManager) ListTargets(ctx context.Context, host string) ([]string, error) {
	return []string{}, nil
}

// ==================== ACL Management ====================

// AddInitiator adds an allowed initiator to the iSCSI gateway
func (i *iSCSIManager) AddInitiator(ctx context.Context, resource, initiatorIQN string) error {
	i.logger.Info("Adding initiator ACL",
		zap.String("resource", resource),
		zap.String("iqn", initiatorIQN))

	// Update the ACL in the target configuration
	return fmt.Errorf("AddInitiator not yet implemented - please recreate gateway")
}

// RemoveInitiator removes an initiator from the iSCSI gateway
func (i *iSCSIManager) RemoveInitiator(ctx context.Context, resource, initiatorIQN string) error {
	i.logger.Info("Removing initiator ACL",
		zap.String("resource", resource),
		zap.String("iqn", initiatorIQN))

	return fmt.Errorf("RemoveInitiator not yet implemented")
}

// ListInitiators lists all initiators for an iSCSI gateway
func (i *iSCSIManager) ListInitiators(ctx context.Context, resource string) ([]string, error) {
	// Read from gateway config or query targetcli
	return []string{}, nil
}

// ==================== CHAP Authentication ====================

// SetCHAP sets CHAP authentication for the iSCSI gateway
func (i *iSCSIManager) SetCHAP(ctx context.Context, resource, username, password string, mutual bool) error {
	i.logger.Info("Setting CHAP authentication",
		zap.String("resource", resource),
		zap.String("username", username),
		zap.Bool("mutual", mutual))

	// Update the gateway configuration with new CHAP credentials
	return fmt.Errorf("SetCHAP not yet implemented - please recreate gateway")
}

// GetCHAP gets CHAP authentication settings
func (i *iSCSIManager) GetCHAP(ctx context.Context, resource string) (username, password string, mutual bool, err error) {
	// Read from gateway config
	return "", "", false, fmt.Errorf("CHAP not configured or not implemented")
}

// ==================== Helper Functions ====================

// generateIQN generates an IQN for a given resource
func generateIQN(resource string) string {
	// Format: iqn.2024-01.com.example:sds.resource-name
	return fmt.Sprintf("iqn.2024-01.com.example:sds.%s", resource)
}

// validateIQN validates an IQN format
func validateIQN(iqn string) error {
	if !strings.HasPrefix(iqn, "iqn.") {
		return fmt.Errorf("invalid IQN format: must start with 'iqn.'")
	}

	parts := strings.Split(iqn, ":")
	if len(parts) < 2 {
		return fmt.Errorf("invalid IQN format: missing colon separator")
	}

	return nil
}

// parsePortal parses an iSCSI portal string (host:port)
func parsePortal(portal string) (string, int, error) {
	host, portStr, err := net.SplitHostPort(portal)
	if err != nil {
		return "", 0, err
	}

	port := 3260 // default iSCSI port
	if portStr != "" {
		fmt.Sscanf(portStr, "%d", &port)
	}

	return host, port, nil
}
