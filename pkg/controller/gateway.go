package controller

import (
	"context"
	"crypto/md5"
	"encoding/hex"
	"fmt"
	"net"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"go.uber.org/zap"
	pb "github.com/liliang-cn/drbd-agent/api/proto/v1"
	v1 "github.com/liliang-cn/sds/api/proto/v1"
	"github.com/liliang-cn/sds/pkg/client"
)

const (
	// DrbdReactorConfigDir is the directory for drbd-reactor configuration snippets
	DrbdReactorConfigDir = "/etc/drbd-reactor.d"

	// Default ports
	DefaultISCSIPort = 3260
	DefaultNFSPort   = 2049
	DefaultNVMePort  = 4420

	// Default filesystem types
	DefaultFSType = "ext4"

	// Default export base path
	DefaultExportBasePath = "/srv/gateway-exports"

	// Default cluster private mount path
	DefaultClusterPrivateMountPath = "/var/lib/sds"
)

// GatewayManager handles gateway operations
type GatewayManager struct {
	controller *Controller
}

// NewGatewayManager creates a new gateway manager
func NewGatewayManager(ctrl *Controller) *GatewayManager {
	return &GatewayManager{
		controller: ctrl,
	}
}

// CreateISCSIGateway creates an iSCSI gateway with drbd-reactor configuration
func (gm *GatewayManager) CreateISCSIGateway(ctx context.Context, req *v1.CreateISCSIGatewayRequest) (*v1.CreateISCSIGatewayResponse, error) {
	gm.controller.logger.Info("Creating iSCSI gateway",
		zap.String("resource", req.Resource),
		zap.String("iqn", req.Iqn),
		zap.String("service_ip", req.ServiceIp))

	// Parse service IP
	serviceIP, err := parseServiceIP(req.ServiceIp)
	if err != nil {
		return &v1.CreateISCSIGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("invalid service IP: %v", err),
		}, err
	}

	// Generate drbd-reactor configuration
	config, err := gm.generateISCSIGatewayConfig(req, serviceIP)
	if err != nil {
		return &v1.CreateISCSIGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("failed to generate config: %v", err),
		}, err
	}

	configPath := filepath.Join(DrbdReactorConfigDir, fmt.Sprintf("sds-iscsi-%s.toml", req.Resource))

	// Write configuration to all nodes via drbd-agent
	gm.controller.agentsLock.RLock()
	agents := make(map[string]*client.AgentClient)
	for k, v := range gm.controller.agents {
		agents[k] = v
	}
	gm.controller.agentsLock.RUnlock()

	for node, agent := range agents {
		// Write config file using drbd-agent's WriteReactorConfig
		pluginID := fmt.Sprintf("sds-iscsi-%s", req.Resource)
		writeResp, err := agent.WriteReactorConfig(ctx, pluginID, config, true)
		if err != nil {
			gm.controller.logger.Warn("Failed to write config on node",
				zap.String("node", node),
				zap.Error(err))
			return &v1.CreateISCSIGatewayResponse{
				Success: false,
				Message: fmt.Sprintf("failed to write config on %s: %v", node, err),
			}, err
		}

		if !writeResp.Success {
			gm.controller.logger.Warn("Failed to write config on node",
				zap.String("node", node),
				zap.String("message", writeResp.Message))
			return &v1.CreateISCSIGatewayResponse{
				Success: false,
				Message: fmt.Sprintf("failed to write config on %s: %s", node, writeResp.Message),
			}, fmt.Errorf(writeResp.Message)
		}

		gm.controller.logger.Info("iSCSI gateway configuration created on node",
			zap.String("node", node),
			zap.String("path", writeResp.ConfigPath))
	}

	// Set resource to Primary on the first available node
	var primaryNode string
	for endpoint := range agents {
		primaryNode = extractNodeName(endpoint)
		break
	}

	if primaryNode != "" {
		gm.controller.logger.Info("Setting resource to Primary for gateway",
			zap.String("resource", req.Resource),
			zap.String("node", primaryNode))

		if err := gm.controller.resources.SetPrimary(ctx, req.Resource, primaryNode, false); err != nil {
			gm.controller.logger.Warn("Failed to set resource to Primary",
				zap.String("resource", req.Resource),
				zap.String("node", primaryNode),
				zap.Error(err))
			// Don't fail the operation if setting primary fails
			// Gateway config is created, user can manually set primary later
		} else {
			gm.controller.logger.Info("Resource set to Primary successfully",
				zap.String("resource", req.Resource),
				zap.String("node", primaryNode))
		}
	}

	return &v1.CreateISCSIGatewayResponse{
		Success:    true,
		Message:    "iSCSI gateway configuration created successfully on all nodes",
		ConfigPath: configPath,
	}, nil
}

// generateISCSIGatewayConfig generates drbd-reactor TOML configuration for iSCSI gateway
func (gm *GatewayManager) generateISCSIGatewayConfig(req *v1.CreateISCSIGatewayRequest, serviceIP *ServiceIP) (string, error) {
	// Template for iSCSI gateway
	tmpl := `# SDS iSCSI Gateway Configuration
# Generated by SDS Controller
# Resource: {{ .Resource }}
# IQN: {{ .IQN }}
# Service IP: {{ .ServiceIP }}

[[promoter]]

  [promoter.metadata]
    linstor-gateway-schema-version = 1

  [promoter.resources]

    [promoter.resources.{{ .Resource }}]
      on-drbd-demote-failure = "reboot-immediate"
      runner = "systemd"
      start = [
        "ocf:heartbeat:Filesystem fs_cluster_private device=/dev/drbd0 directory={{ .ClusterPrivatePath }} fstype={{ .FSType }} run_fsck=no",
        "ocf:heartbeat:portblock pblock0 ip={{ .IPAddress }} portno={{ .ISCSIPort }} action=block protocol=tcp",
        "ocf:heartbeat:IPaddr2 service_ip0 ip={{ .IPAddress }} cidr_netmask={{ .Prefix }}",
        "ocf:heartbeat:iSCSITarget target iqn={{ .IQN }} portals={{ .Portal }} incoming_username={{ .Username }} incoming_password={{ .Password }} allowed_initiators={{ .AllowedInitiators }} implementation={{ .Implementation }}",
{{ range $index, $element := .LUNs }}
        "ocf:heartbeat:iSCSILogicalUnit lu{{ $index }} target_iqn={{ $.IQN }} lun={{ $index }} path=/dev/drbd{{ $index }} product_id={{ $.ProductID }} scsi_sn={{ $.SCSISN }}",
{{ end }}
        "ocf:heartbeat:portblock portunblock0 ip={{ .IPAddress }} portno={{ .ISCSIPort }} action=unblock protocol=tcp tickle_dir={{ .ClusterPrivatePath }}",
      ]
      stop-services-on-exit = true
      target-as = "Requires"
`

	// Parse service IP
	ipAddr := serviceIP.IP.String()
	prefix := serviceIP.Prefix
	portal := fmt.Sprintf("%s:%d", ipAddr, DefaultISCSIPort)

	// Generate SCSI serial number from IQN
	hash := md5.Sum([]byte(req.Iqn))
	productID := hex.EncodeToString(hash[:4])
	scsiSN := hex.EncodeToString(hash[:4])

	// Prepare template data
	data := struct {
		Resource           string
		IQN                string
		ServiceIP          string
		IPAddress          string
		Prefix             int
		Portal             string
		FSType             string
		ClusterPrivatePath string
		ISCSIPort          int
		Username           string
		Password           string
		AllowedInitiators  string
		Implementation     string
		LUNs               []int
		ProductID          string
		SCSISN             string
	}{
		Resource:           req.Resource,
		IQN:                req.Iqn,
		ServiceIP:          req.ServiceIp,
		IPAddress:          ipAddr,
		Prefix:             prefix,
		Portal:             portal,
		FSType:             DefaultFSType,
		ClusterPrivatePath: filepath.Join(DefaultClusterPrivateMountPath, req.Resource+"-cluster-private"),
		ISCSIPort:          DefaultISCSIPort,
		Username:           req.Username,
		Password:           req.Password,
		AllowedInitiators:  strings.Join(req.AllowedInitiators, " "),
		Implementation:     req.Implementation,
		LUNs:               []int{1, 2}, // TODO: Get actual volumes from resource
		ProductID:          productID,
		SCSISN:             scsiSN,
	}

	if data.Implementation == "" {
		data.Implementation = "lio"
	}

	// Execute template
	t, err := template.New("iscsi").Parse(tmpl)
	if err != nil {
		return "", err
	}

	var result strings.Builder
	if err := t.Execute(&result, data); err != nil {
		return "", err
	}

	return result.String(), nil
}

// CreateNFSGateway creates an NFS gateway with drbd-reactor configuration
func (gm *GatewayManager) CreateNFSGateway(ctx context.Context, req *v1.CreateNFSGatewayRequest) (*v1.CreateNFSGatewayResponse, error) {
	gm.controller.logger.Info("Creating NFS gateway",
		zap.String("resource", req.Resource),
		zap.String("service_ip", req.ServiceIp),
		zap.String("export_path", req.ExportPath))

	// Parse service IP
	serviceIP, err := parseServiceIP(req.ServiceIp)
	if err != nil {
		return &v1.CreateNFSGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("invalid service IP: %v", err),
		}, err
	}

	// Get resource info to find actual DRBD device paths
	resource, err := gm.controller.resources.GetResource(ctx, req.Resource)
	if err != nil {
		return &v1.CreateNFSGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("failed to get resource info: %v", err),
		}, err
	}

	if len(resource.Volumes) == 0 {
		return &v1.CreateNFSGatewayResponse{
			Success: false,
			Message: "resource has no volumes",
		}, fmt.Errorf("resource %s has no volumes", req.Resource)
	}

	// Try to get device from resource info, if empty, try to get from DRBD config
	drbdDevice := resource.Volumes[0].Device
	if drbdDevice == "" {
		// Get device from DRBD config file
		drbdDevice, err = gm.getDeviceFromDRBDConfig(ctx, req.Resource)
		if err != nil {
			gm.controller.logger.Warn("Failed to get device from DRBD config",
				zap.String("resource", req.Resource),
				zap.Error(err))
			// Fallback to /dev/drbd0
			drbdDevice = "/dev/drbd0"
		}
	}

	gm.controller.logger.Info("Using DRBD device for NFS gateway",
		zap.String("resource", req.Resource),
		zap.String("device", drbdDevice))

	// Generate drbd-reactor configuration
	config, err := gm.generateNFSGatewayConfig(req, serviceIP, drbdDevice)
	if err != nil {
		return &v1.CreateNFSGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("failed to generate config: %v", err),
		}, err
	}

	configPath := filepath.Join(DrbdReactorConfigDir, fmt.Sprintf("sds-nfs-%s.toml", req.Resource))

	// Write configuration to all nodes via drbd-agent
	gm.controller.agentsLock.RLock()
	agents := make(map[string]*client.AgentClient)
	for k, v := range gm.controller.agents {
		agents[k] = v
	}
	gm.controller.agentsLock.RUnlock()

	for node, agent := range agents {
		// Write config file using drbd-agent's WriteReactorConfig
		pluginID := fmt.Sprintf("sds-nfs-%s", req.Resource)
		writeResp, err := agent.WriteReactorConfig(ctx, pluginID, config, true)
		if err != nil {
			gm.controller.logger.Warn("Failed to write config on node",
				zap.String("node", node),
				zap.Error(err))
			return &v1.CreateNFSGatewayResponse{
				Success: false,
				Message: fmt.Sprintf("failed to write config on %s: %v", node, err),
			}, err
		}

		if !writeResp.Success {
			gm.controller.logger.Warn("Failed to write config on node",
				zap.String("node", node),
				zap.String("message", writeResp.Message))
			return &v1.CreateNFSGatewayResponse{
				Success: false,
				Message: fmt.Sprintf("failed to write config on %s: %s", node, writeResp.Message),
			}, fmt.Errorf(writeResp.Message)
		}

		gm.controller.logger.Info("NFS gateway configuration created on node",
			zap.String("node", node),
			zap.String("path", writeResp.ConfigPath))
	}

	// Set resource to Primary on the first available node
	var primaryNode string
	for endpoint := range agents {
		primaryNode = extractNodeName(endpoint)
		break
	}

	if primaryNode != "" {
		gm.controller.logger.Info("Setting resource to Primary for gateway",
			zap.String("resource", req.Resource),
			zap.String("node", primaryNode))

		if err := gm.controller.resources.SetPrimary(ctx, req.Resource, primaryNode, false); err != nil {
			gm.controller.logger.Warn("Failed to set resource to Primary",
				zap.String("resource", req.Resource),
				zap.String("node", primaryNode),
				zap.Error(err))
			// Don't fail the operation if setting primary fails
			// Gateway config is created, user can manually set primary later
		} else {
			gm.controller.logger.Info("Resource set to Primary successfully",
				zap.String("resource", req.Resource),
				zap.String("node", primaryNode))
		}
	}

	return &v1.CreateNFSGatewayResponse{
		Success:    true,
		Message:    "NFS gateway configuration created successfully on all nodes",
		ConfigPath: configPath,
	}, nil
}

// generateNFSGatewayConfig generates drbd-reactor TOML configuration for NFS gateway
func (gm *GatewayManager) generateNFSGatewayConfig(req *v1.CreateNFSGatewayRequest, serviceIP *ServiceIP, drbdDevice string) (string, error) {
	// Template for NFS gateway
	tmpl := `# SDS NFS Gateway Configuration
# Generated by SDS Controller
# Resource: {{ .Resource }}
# Service IP: {{ .ServiceIP }}
# Export Path: {{ .ExportPath }}

[[promoter]]

  [promoter.metadata]
    linstor-gateway-schema-version = 1

  [promoter.resources]

    [promoter.resources.{{ .Resource }}]
      on-drbd-demote-failure = "reboot-immediate"
      runner = "systemd"
      start = [
        "ocf:heartbeat:Filesystem fs_cluster_private device={{ .DRBDDevice }} directory={{ .ClusterPrivatePath }} fstype={{ .FSType }} run_fsck=no",
{{ range $index, $element := .Mounts }}
        "ocf:heartbeat:Filesystem fs_{{ $index }} device={{ $.DRBDDevice }} directory={{ .Directory }} fstype={{ $.FSType }} run_fsck=no",
{{ end }}
        "ocf:heartbeat:IPaddr2 service_ip ip={{ .IPAddress }} cidr_netmask={{ .Prefix }}",
        "ocf:heartbeat:nfsserver nfsserver nfs_ip={{ .IPAddress }} nfs_shared_infodir={{ .NFSInfoDir }} nfs_server_scope={{ .IPAddress }}",
{{ range $index, $element := .Exports }}
        "ocf:heartbeat:exportfs export_{{ $index }}_0 directory={{ .Directory }} fsid={{ .FSID }} clientspec={{ .ClientSpec }} options={{ .Options }}",
{{ end }}
      ]
      stop-services-on-exit = true
      target-as = "BindsTo"
`

	ipAddr := serviceIP.IP.String()
	prefix := serviceIP.Prefix
	fsType := req.FsType
	if fsType == "" {
		fsType = DefaultFSType
	}

	// Prepare export and mount data
	exportsPath := filepath.Join(DefaultExportBasePath, req.Resource, req.ExportPath)

	// Generate a simple numeric FSID based on resource name hash
	hash := md5.Sum([]byte(req.Resource))
	fsid := int(hash[0])<<24 | int(hash[1])<<16 | int(hash[2])<<8 | int(hash[3])
	if fsid < 0 {
		fsid = -fsid
	}
	// Ensure FSID is positive and not too large
	fsid = (fsid % 1000000) + 100

	exports := []map[string]string{
		{
			"Directory":  exportsPath,
			"FSID":       fmt.Sprintf("%d", fsid),
			"ClientSpec": "0.0.0.0/0.0.0.0",
			"Options":    "rw,all_squash,anonuid=0,anongid=0",
		},
	}

	if len(req.AllowedIps) > 0 {
		exports[0]["ClientSpec"] = req.AllowedIps[0]
	}

	// Prepare mount data (directory only, device is from DRBD)
	mounts := []map[string]string{
		{
			"Directory": exportsPath,
		},
	}

	nfsInfoDir := filepath.Join(DefaultClusterPrivateMountPath, req.Resource+"-cluster-private", "nfs")

	data := struct {
		Resource           string
		ServiceIP          string
		IPAddress          string
		Prefix             int
		FSType             string
		ExportPath         string
		ClusterPrivatePath string
		NFSPort            int
		NFSInfoDir         string
		DRBDDevice         string
		Exports            []map[string]string
		Mounts             []map[string]string
	}{
		Resource:           req.Resource,
		ServiceIP:          req.ServiceIp,
		IPAddress:          ipAddr,
		Prefix:             prefix,
		FSType:             fsType,
		DRBDDevice:         drbdDevice,
		ExportPath:         req.ExportPath,
		ClusterPrivatePath: filepath.Join(DefaultClusterPrivateMountPath, req.Resource+"-cluster-private"),
		NFSPort:            DefaultNFSPort,
		NFSInfoDir:         nfsInfoDir,
		Exports:            exports,
		Mounts:             mounts,
	}

	// Execute template
	t, err := template.New("nfs").Parse(tmpl)
	if err != nil {
		return "", err
	}

	var result strings.Builder
	if err := t.Execute(&result, data); err != nil {
		return "", err
	}

	return result.String(), nil
}

// CreateNVMeGateway creates an NVMe-oF gateway with drbd-reactor configuration
func (gm *GatewayManager) CreateNVMeGateway(ctx context.Context, req *v1.CreateNVMeGatewayRequest) (*v1.CreateNVMeGatewayResponse, error) {
	gm.controller.logger.Info("Creating NVMe-oF gateway",
		zap.String("resource", req.Resource),
		zap.String("nqn", req.Nqn),
		zap.String("service_ip", req.ServiceIp))

	// Parse service IP
	serviceIP, err := parseServiceIP(req.ServiceIp)
	if err != nil {
		return &v1.CreateNVMeGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("invalid service IP: %v", err),
		}, err
	}

	// Generate drbd-reactor configuration
	config, err := gm.generateNVMeGatewayConfig(req, serviceIP)
	if err != nil {
		return &v1.CreateNVMeGatewayResponse{
			Success: false,
			Message: fmt.Sprintf("failed to generate config: %v", err),
		}, err
	}

	configPath := filepath.Join(DrbdReactorConfigDir, fmt.Sprintf("sds-nvmeof-%s.toml", req.Resource))

	// Write configuration to all nodes via drbd-agent
	gm.controller.agentsLock.RLock()
	agents := make(map[string]*client.AgentClient)
	for k, v := range gm.controller.agents {
		agents[k] = v
	}
	gm.controller.agentsLock.RUnlock()

	for node, agent := range agents {
		// Write config file using drbd-agent's WriteReactorConfig
		pluginID := fmt.Sprintf("sds-nvmeof-%s", req.Resource)
		writeResp, err := agent.WriteReactorConfig(ctx, pluginID, config, true)
		if err != nil {
			gm.controller.logger.Warn("Failed to write config on node",
				zap.String("node", node),
				zap.Error(err))
			return &v1.CreateNVMeGatewayResponse{
				Success: false,
				Message: fmt.Sprintf("failed to write config on %s: %v", node, err),
			}, err
		}

		if !writeResp.Success {
			gm.controller.logger.Warn("Failed to write config on node",
				zap.String("node", node),
				zap.String("message", writeResp.Message))
			return &v1.CreateNVMeGatewayResponse{
				Success: false,
				Message: fmt.Sprintf("failed to write config on %s: %s", node, writeResp.Message),
			}, fmt.Errorf(writeResp.Message)
		}

		gm.controller.logger.Info("NVMe-oF gateway configuration created on node",
			zap.String("node", node),
			zap.String("path", writeResp.ConfigPath))
	}

	// Set resource to Primary on the first available node
	var primaryNode string
	for endpoint := range agents {
		primaryNode = extractNodeName(endpoint)
		break
	}

	if primaryNode != "" {
		gm.controller.logger.Info("Setting resource to Primary for gateway",
			zap.String("resource", req.Resource),
			zap.String("node", primaryNode))

		if err := gm.controller.resources.SetPrimary(ctx, req.Resource, primaryNode, false); err != nil {
			gm.controller.logger.Warn("Failed to set resource to Primary",
				zap.String("resource", req.Resource),
				zap.String("node", primaryNode),
				zap.Error(err))
			// Don't fail the operation if setting primary fails
			// Gateway config is created, user can manually set primary later
		} else {
			gm.controller.logger.Info("Resource set to Primary successfully",
				zap.String("resource", req.Resource),
				zap.String("node", primaryNode))
		}
	}

	return &v1.CreateNVMeGatewayResponse{
		Success:    true,
		Message:    "NVMe-oF gateway configuration created successfully on all nodes",
		ConfigPath: configPath,
	}, nil
}

// generateNVMeGatewayConfig generates drbd-reactor TOML configuration for NVMe-oF gateway
func (gm *GatewayManager) generateNVMeGatewayConfig(req *v1.CreateNVMeGatewayRequest, serviceIP *ServiceIP) (string, error) {
	// Template for NVMe-oF gateway
	tmpl := `# SDS NVMe-oF Gateway Configuration
# Generated by SDS Controller
# Resource: {{ .Resource }}
# NQN: {{ .NQN }}
# Service IP: {{ .ServiceIP }}

[[promoter]]

  [promoter.metadata]
    linstor-gateway-schema-version = 1

  [promoter.resources]

    [promoter.resources.{{ .SubsystemID }}]
      on-drbd-demote-failure = "reboot-immediate"
      runner = "systemd"
      start = [
        "ocf:heartbeat:portblock portblock ip={{ .IPAddress }} portno={{ .NVMePort }} action=block protocol=tcp",
        "ocf:heartbeat:Filesystem fs_cluster_private device=/dev/drbd0 directory={{ .ClusterPrivatePath }} fstype={{ .FSType }} run_fsck=no",
        "ocf:heartbeat:IPaddr2 service_ip ip={{ .IPAddress }} cidr_netmask={{ .Prefix }}",
        "ocf:heartbeat:nvmet-subsystem subsys nqn={{ .NQN }} serial={{ .Serial }}",
{{ range $index, $element := .Namespaces }}
        "ocf:heartbeat:nvmet-namespace ns_{{ $index }} nqn={{ $.NQN }} namespace_id={{ $index }} backing_path=/dev/drbd{{ $index }} uuid={{ .UUID }} nguid={{ .NGUID }}",
{{ end }}
        "ocf:heartbeat:nvmet-port port nqns={{ .NQN }} addr={{ .IPAddress }} type={{ .TransportType }}",
        "ocf:heartbeat:portblock portunblock ip={{ .IPAddress }} portno={{ .NVMePort }} action=unblock protocol=tcp tickle_dir={{ .ClusterPrivatePath }}",
      ]
      stop-services-on-exit = true
      target-as = "Requires"
`

	ipAddr := serviceIP.IP.String()
	prefix := serviceIP.Prefix
	transportType := req.TransportType
	if transportType == "" {
		transportType = "tcp"
	}

	// Generate serial from NQN
	hash := md5.Sum([]byte(req.Nqn))
	serial := hex.EncodeToString(hash[:8])

	// Prepare subsystem ID (extract subsystem name from NQN)
	// Format: nqn.2024-01.com.example:subsystem.name -> subsystem.name
	subsystemID := req.Nqn
	if parts := strings.SplitN(req.Nqn, ":", 2); len(parts) == 2 {
		subsystemID = parts[1]
	}

	// Prepare namespace data
	namespaces := []map[string]string{
		{
			"UUID":  generateUUID(),
			"NGUID": generateUUID(),
		},
		{
			"UUID":  generateUUID(),
			"NGUID": generateUUID(),
		},
	}

	data := struct {
		Resource           string
		NQN                string
		SubsystemID        string
		ServiceIP          string
		IPAddress          string
		Prefix             int
		FSType             string
		ClusterPrivatePath string
		NVMePort           int
		Serial             string
		TransportType      string
		Namespaces         []map[string]string
	}{
		Resource:           req.Resource,
		NQN:                req.Nqn,
		SubsystemID:        subsystemID,
		ServiceIP:          req.ServiceIp,
		IPAddress:          ipAddr,
		Prefix:             prefix,
		FSType:             DefaultFSType,
		ClusterPrivatePath: filepath.Join(DefaultClusterPrivateMountPath, "nvme-cluster-private"),
		NVMePort:           DefaultNVMePort,
		Serial:             serial,
		TransportType:      transportType,
		Namespaces:         namespaces,
	}

	// Execute template
	t, err := template.New("nvme").Parse(tmpl)
	if err != nil {
		return "", err
	}

	var result strings.Builder
	if err := t.Execute(&result, data); err != nil {
		return "", err
	}

	return result.String(), nil
}

// ServiceIP represents a service IP with CIDR notation
type ServiceIP struct {
	IP     net.IP
	Prefix int
}

// extractNodeName extracts node name from endpoint (e.g., "orange1:50051" -> "orange1")
func extractNodeName(endpoint string) string {
	// Split by : to remove port
	parts := strings.Split(endpoint, ":")
	if len(parts) > 0 {
		return parts[0]
	}
	return endpoint
}

// parseServiceIP parses a service IP with CIDR notation
func parseServiceIP(serviceIP string) (*ServiceIP, error) {
	ip, ipNet, err := net.ParseCIDR(serviceIP)
	if err != nil {
		return nil, fmt.Errorf("failed to parse service IP %s: %w", serviceIP, err)
	}

	prefix, _ := ipNet.Mask.Size()

	return &ServiceIP{
		IP:     ip,
		Prefix: prefix,
	}, nil
}

// generateUUID generates a simple UUID for use in configurations
func generateUUID() string {
	// Simple UUID generation - in production use crypto/rand or uuid package
	return fmt.Sprintf("%08x-%04x-%04x-%04x-%012x",
		md5.Sum([]byte(fmt.Sprintf("%d", randInt()))),
		randShort(), randShort(), randShort(),
		md5.Sum([]byte(fmt.Sprintf("%d", randInt()))))
}

// Helper functions for UUID generation
func randInt() int {
	// In production, use crypto/rand
	return 12345
}

func randShort() uint16 {
	// In production, use crypto/rand
	return 0x1234
}

// DeleteGateway deletes a gateway configuration
func (gm *GatewayManager) DeleteGateway(ctx context.Context, id string) error {
	gm.controller.logger.Info("Deleting gateway",
		zap.String("id", id))

	// Get all agents
	gm.controller.agentsLock.RLock()
	agents := make(map[string]*client.AgentClient)
	for k, v := range gm.controller.agents {
		agents[k] = v
	}
	gm.controller.agentsLock.RUnlock()

	// Stop drbd-reactor services and remove config on all nodes
	for node, agent := range agents {
		gm.controller.logger.Info("Stopping gateway services on node",
			zap.String("node", node),
			zap.String("gateway", id))

		// 1. Stop drbd-reactor services for this gateway
		stopReq := &pb.ExecCommandRequest{
			Command: "systemctl",
			Args:    []string{"stop", fmt.Sprintf("drbd-services@%s.target", strings.ReplaceAll(id, "-", "\\x2d"))},
		}

		stopResp, err := agent.ExecCommand(ctx, stopReq)
		if err != nil {
			gm.controller.logger.Warn("Failed to stop gateway services",
				zap.String("node", node),
				zap.Error(err))
			// Continue anyway
		} else if !stopResp.Success {
			gm.controller.logger.Warn("Failed to stop gateway services",
				zap.String("node", node),
				zap.String("message", stopResp.Message))
			// Continue anyway
		}

		// 2. Delete reactor config files (all types: nfs, iscsi, nvmeof)
		configFiles := []string{
			fmt.Sprintf("sds-nfs-%s.toml", id),
			fmt.Sprintf("sds-iscsi-%s.toml", id),
			fmt.Sprintf("sds-nvmeof-%s.toml", id),
		}

		for _, configFile := range configFiles {
			configPath := filepath.Join(DrbdReactorConfigDir, configFile)

			rmReq := &pb.ExecCommandRequest{
				Command: "rm",
				Args:    []string{"-f", configPath},
			}

			rmResp, err := agent.ExecCommand(ctx, rmReq)
			if err != nil {
				gm.controller.logger.Warn("Failed to delete config",
					zap.String("node", node),
					zap.String("config", configFile),
					zap.Error(err))
			} else if !rmResp.Success && !strings.Contains(rmResp.Message, "No such file") {
				gm.controller.logger.Warn("Failed to delete config",
					zap.String("node", node),
					zap.String("config", configFile),
					zap.String("message", rmResp.Message))
			} else {
				gm.controller.logger.Info("Deleted gateway config",
					zap.String("node", node),
					zap.String("config", configFile))
			}
		}

		// 3. Reload drbd-reactor to pick up changes
		reloadReq := &pb.ExecCommandRequest{
			Command: "systemctl",
			Args:    []string{"reload", "drbd-reactor"},
		}

		reloadResp, err := agent.ExecCommand(ctx, reloadReq)
		if err != nil {
			gm.controller.logger.Warn("Failed to reload drbd-reactor",
				zap.String("node", node),
				zap.Error(err))
		} else if !reloadResp.Success {
			gm.controller.logger.Warn("Failed to reload drbd-reactor",
				zap.String("node", node),
				zap.String("message", reloadResp.Message))
		} else {
			gm.controller.logger.Info("Reloaded drbd-reactor",
				zap.String("node", node))
		}
	}

	gm.controller.logger.Info("Gateway deleted successfully",
		zap.String("id", id))

	return nil
}

// GetGateway retrieves gateway information
func (gm *GatewayManager) GetGateway(ctx context.Context, id string) (*GatewayInfo, error) {
	// TODO: Implement gateway state tracking
	return &GatewayInfo{
		ID:   id,
		Name: id,
		Type: "unknown",
	}, nil
}

// ListGateways lists all configured gateways
func (gm *GatewayManager) ListGateways(ctx context.Context) ([]*GatewayInfo, error) {
	// Scan drbd-reactor config directory
	files, err := os.ReadDir(DrbdReactorConfigDir)
	if err != nil {
		return nil, fmt.Errorf("failed to read config directory: %w", err)
	}

	var gateways []*GatewayInfo
	for _, file := range files {
		if strings.HasPrefix(file.Name(), "sds-") && strings.HasSuffix(file.Name(), ".toml") {
			// Parse gateway type and name from filename
			// Format: sds-<type>-<resource>.toml
			parts := strings.TrimPrefix(file.Name(), "sds-")
			parts = strings.TrimSuffix(parts, ".toml")
			typeParts := strings.SplitN(parts, "-", 2)

			if len(typeParts) == 2 {
				gwType := typeParts[0]
				resource := typeParts[1]

				gateways = append(gateways, &GatewayInfo{
					ID:       resource,
					Name:     resource,
					Type:     gwType,
					Resource: resource,
				})
			}
		}
	}

	return gateways, nil
}

// StartGateway starts a gateway
func (gm *GatewayManager) StartGateway(ctx context.Context, id string) error {
	// Reload drbd-reactor to pick up new configuration
	return gm.reloadDrbdReactor()
}

// StopGateway stops a gateway
func (gm *GatewayManager) StopGateway(ctx context.Context, id string) error {
	// TODO: Implement stopping individual gateways
	return fmt.Errorf("stopping individual gateways not yet implemented")
}

// reloadDrbdReactor reloads drbd-reactor configuration
func (gm *GatewayManager) reloadDrbdReactor() error {
	// This would typically be done via systemctl reload drbd-reactor
	// For now, just log
	gm.controller.logger.Info("drbd-reactor reload requested")
	return nil
}

// GatewayInfo represents gateway information
type GatewayInfo struct {
	ID       string
	Name     string
	Type     string
	Resource string
}

// getDeviceFromDRBDConfig reads DRBD config file and extracts device path
func (gm *GatewayManager) getDeviceFromDRBDConfig(ctx context.Context, resource string) (string, error) {
	// Try to read local DRBD config file first (controller runs on each node)
	configPath := fmt.Sprintf("/etc/drbd.d/%s.res", resource)
	content, err := os.ReadFile(configPath)
	if err == nil {
		// Parse local config
		configContent := string(content)
		lines := strings.Split(configContent, "\n")
		inVolumeBlock := false
		var deviceMinor string

		for _, line := range lines {
			line = strings.TrimSpace(line)

			// Check if we're entering a volume block
			if strings.Contains(line, "volume") && strings.Contains(line, "{") {
				inVolumeBlock = true
				continue
			}

			// Check if we're exiting a volume block
			if line == "}" {
				if inVolumeBlock && deviceMinor != "" {
					// Found it!
					devicePath := fmt.Sprintf("/dev/drbd%s", deviceMinor)
					gm.controller.logger.Info("Found device minor in local DRBD config",
						zap.String("resource", resource),
						zap.String("device", devicePath))
					return devicePath, nil
				}
				inVolumeBlock = false
				deviceMinor = ""
				continue
			}

			// Inside volume block, look for device minor
			if inVolumeBlock && strings.Contains(line, "device") && strings.Contains(line, "minor") {
				// Parse: device    minor 100;
				parts := strings.Fields(line)
				for i, part := range parts {
					if part == "minor" && i+1 < len(parts) {
						deviceMinor = strings.TrimSuffix(parts[i+1], ";")
					}
				}
			}
		}
	}

	// Get any agent to query DRBD (if local read failed)
	gm.controller.agentsLock.RLock()
	var agent *client.AgentClient
	for _, a := range gm.controller.agents {
		agent = a
		break
	}
	gm.controller.agentsLock.RUnlock()

	if agent == nil {
		return "", fmt.Errorf("no agents available and local config not found")
	}

	// Use drbdsetup to get device path for the resource
	// drbdsetup shows the actual device path like /dev/drbd100
	req := &pb.ExecCommandRequest{
		Command: "/bin/sh",
		Args:    []string{"-c", fmt.Sprintf("drbdsetup show %s 2>/dev/null | grep -E '^device' | head -1 | awk '{print $2}'", resource)},
	}

	resp, err := agent.ExecCommand(ctx, req)
	if err != nil {
		return "", fmt.Errorf("failed to get device: %w", err)
	}

	devicePath := strings.TrimSpace(resp.Stdout)
	if devicePath != "" && strings.HasPrefix(devicePath, "/dev/drbd") {
		gm.controller.logger.Info("Found DRBD device via drbdsetup",
			zap.String("resource", resource),
			zap.String("device", devicePath))
		return devicePath, nil
	}

	// Log that drbdsetup failed
	gm.controller.logger.Info("drbdsetup did not return device",
		zap.String("resource", resource),
		zap.String("stdout", resp.Stdout))

	return "", fmt.Errorf("device minor not found in config")
}

// Helper function to get minimum of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}


